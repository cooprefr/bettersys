{
  "technologies": [
    {
      "value": "Rust",
      "value_citation": "https://docs.privy.io/basics/rust/quickstart"
    },
    {
      "value": "TypeScript",
      "value_citation": "https://docs.privy.io/basics/react/setup"
    },
    {
      "value": "React 18",
      "value_citation": "https://docs.privy.io/basics/react/quickstart"
    },
    {
      "value": "TailwindCSS",
      "value_citation": "https://github.com/Polymarket/privy-safe-builder-example"
    },
    {
      "value": "Vite",
      "value_citation": "https://docs.privy.io/basics/react/setup"
    }
  ],
  "privy_integration": {
    "privy_setup": "1. Installation: Install the Privy React SDK via npm: `npm install @privy-io/react-auth`\n\n2. Prerequisites: Obtain a Privy App ID from the Privy Dashboard at https://dashboard.privy.io\n\n3. Provider Configuration: Wrap your application in the PrivyProvider component at the root level (e.g., in App.tsx or Next.js layout):\n\n```typescript\n'use client';\nimport {PrivyProvider} from '@privy-io/react-auth';\n\nexport default function Providers({children}: {children: React.ReactNode}) {\n  return (\n    <PrivyProvider\n      appId=\"your-privy-app-id\"\n      config={{\n        embeddedWallets: {\n          ethereum: {\n            createOnLogin: 'users-without-wallets'\n          }\n        }\n      }}\n    >\n      {children}\n    </PrivyProvider>\n  );\n}\n```\n\n4. Authentication Flow: Use the usePrivy hook to enable user login via email OTP:\n\n```typescript\nimport {useState} from 'react';\nimport {useLoginWithEmail, usePrivy} from '@privy-io/react-auth';\n\nexport default function Login() {\n  const [email, setEmail] = useState('');\n  const [code, setCode] = useState('');\n  const {sendCode, loginWithCode} = useLoginWithEmail();\n  const {ready, authenticated} = usePrivy();\n\n  if (!ready) return <div>Loading...</div>;\n\n  return (\n    <div>\n      <input onChange={(e) => setEmail(e.target.value)} value={email} />\n      <button onClick={() => sendCode({email})}>Send Code</button>\n      <input onChange={(e) => setCode(e.target.value)} value={code} />\n      <button onClick={() => loginWithCode({code})}>Login</button>\n    </div>\n  );\n}\n```\n\n5. Automatic Wallet Creation: Configure embedded wallet creation in the PrivyProvider config to automatically generate Ethereum wallets upon user login by setting `embeddedWallets.ethereum.createOnLogin` to 'users-without-wallets'.",
    "privy_setup_citation": "https://docs.privy.io/basics/react/setup",
    "wallet_usage": "1. Accessing Wallets: Use the useWallets hook to retrieve connected wallets:\n\n```typescript\nimport {useWallets} from '@privy-io/react-auth';\n\nfunction YourComponent() {\n  const {wallets, ready} = useWallets();\n  \n  if (!ready) return <div>Loading wallets...</div>;\n  \n  const embeddedWallet = wallets[0]; // First wallet is typically the embedded wallet\n  return <div>Wallet Address: {embeddedWallet.address}</div>;\n}\n```\n\n2. Transaction Signing: Use the useSendTransaction hook for EVM transactions:\n\n```typescript\nimport {useSendTransaction} from '@privy-io/react-auth';\n\nexport default function SendTransaction() {\n  const {sendTransaction} = useSendTransaction();\n  \n  const onSend = async () => {\n    await sendTransaction({\n      to: '0xRecipientAddress',\n      value: 100000, // in wei\n      chainId: 137 // Polygon mainnet for Polymarket\n    });\n  };\n  \n  return <button onClick={onSend}>Send Transaction</button>;\n}\n```\n\n3. Web3 Library Integration: Integrate with viem, ethers, or web3.js for advanced operations:\n\n**Viem Integration:**\n```typescript\nimport {toViemAccount, useWallets} from '@privy-io/react-auth';\nimport {createWalletClient, custom} from 'viem';\nimport {polygon} from 'viem/chains';\n\nconst {wallets} = useWallets();\nconst wallet = wallets[0];\nconst provider = await wallet.getEthereumProvider();\nconst account = await toViemAccount({wallet});\n\nconst walletClient = createWalletClient({\n  account: wallet.address as Hex,\n  chain: polygon,\n  transport: custom(provider),\n});\n```\n\n**Ethers.js Integration:**\n```typescript\nimport {ethers} from 'ethers';\n\nconst provider = await wallet.getEthereumProvider();\nconst ethersProvider = new ethers.BrowserProvider(provider);\nconst signer = await ethersProvider.getSigner();\n```\n\n4. Chain Switching: Before signing transactions, ensure the wallet is on the correct network:\n\n```typescript\nawait wallet.switchChain(137); // Switch to Polygon for Polymarket\n```\n\n5. Message Signing: Sign EIP-712 messages for API authentication:\n\n```typescript\nconst provider = await wallet.getEthereumProvider();\nconst ethersProvider = new ethers.BrowserProvider(provider);\nconst signer = await ethersProvider.getSigner();\nconst signature = await signer.signMessage('Your message');\n```",
    "wallet_usage_citation": "https://docs.privy.io/wallets/using-wallets/ethereum/web3-integrations"
  },
  "enclave_integration": {
    "enclave_setup": "1. Account Model Understanding: Enclave provides an integrated account model that unifies asset ownership and abstraction across multiple blockchain networks (EVM, Solana, Bitcoin). The account encapsulates assets, identity, and permissions in a single interface.\n\n2. Smart Account Configuration: Enclave Smart Accounts support multiple ownership options:\n   - Biometric-Based: Fingerprint, face, or voice recognition without seed phrases\n   - EOA-Based: Integration with existing Ethereum, Solana, and Bitcoin wallets (MetaMask, Ledger)\n   - Social Authentication: Google, Apple, and Twitter sign-in via secure background key management\n\n3. SDK/API Integration: Enclave provides SDK/APIs that enable developers to add chain-abstracted functionality to web or mobile interfaces. The SDK abstracts blockchain infrastructure complexities, allowing users to interact with multiple chains as if they were a single network.\n\n4. Asset Deposit: Users deposit assets (USDC, USDT, or other tokens) into their Enclave integrated account. Once deposited, these assets become available for instant cross-chain spending without manual bridging.\n\n5. Developer Integration Process:\n   - Integrate Enclave SDK into your React/TypeScript application\n   - Configure the integrated account model for your users\n   - Enable permissioned session keys for granular access control\n   - Implement custom bundlers and paymasters for gasless transactions\n   - Set up automatic route optimization across chains and protocols\n\n6. Session Keys Configuration: Implement permissioned session keys with:\n   - Granular permissions for specific actions/conditions\n   - Time-bounded and scope-limited access\n   - Secure delegation and revocable permission sets\n\nNote: Specific SDK installation commands and code examples are not available in the current Enclave documentation at https://docs.enclave.money. Developers should contact Enclave directly or monitor their documentation for detailed integration guides.",
    "enclave_setup_citation": "https://docs.enclave.money/introducing-enclave-money/enclave-smart-accounts",
    "gasless_transactions": "1. Gas Abstraction Overview: Enclave enables three primary gasless transaction methods:\n   - Sponsored Transactions: Developers can sponsor gas fees for users, providing a completely free experience\n   - Flexible Payment: Users pay gas in any ERC20 token or stablecoin of their choice (e.g., pay for a Base transaction using USDC)\n   - Cross-Chain Gas Payment: Users can pay for gas using funds on a different network (e.g., pay for an Optimism transaction using USDC on Base)\n\n2. Paymaster Implementation: Developers integrate custom paymasters to enable gasless transactions:\n   - Configure paymaster contracts to sponsor user transactions\n   - Set spending limits and conditions for sponsored transactions\n   - Implement gas fee abstraction so users never need native network tokens (ETH, MATIC, etc.)\n\n3. Custom Bundler Integration: Enclave leverages custom bundlers to:\n   - Support low-cost transaction fees\n   - Eliminate the requirement for users to hold native gas tokens\n   - Bundle multiple operations into atomic transactions\n\n4. Balance Abstraction for Gasless Transactions: Enable users to spend fragmented balances across multiple chains in a single atomic transaction:\n   - Example: A user with 10 USDC on Arbitrum, 10 USDC on Optimism, and 10 USDC on Base can spend 30 USDC in one transaction without bridging\n   - Zero bridge latency - transactions execute instantly on the target chain\n   - Users maintain full custody of their assets across all chains\n\n5. Asset Abstraction: Enable fungibility between different representations of the same asset:\n   - Example: USDC, USDT, and DAI can be treated as interchangeable stablecoin value\n   - Example: WBTC and cbBTC can be used interchangeably for Bitcoin-pegged assets\n   - Automatic asset conversion during transaction execution\n\n6. Multi-Chain Transaction Flow:\n   - User initiates a transaction on any supported chain\n   - Enclave's orchestration layer identifies available balances across all chains\n   - The system automatically routes the transaction using the optimal combination of assets\n   - Gasless execution occurs via paymaster sponsorship or user's choice of payment token\n   - No manual bridging, wrapping, or native token acquisition required\n\n7. Implementation Benefits:\n   - Transact instantly on any chain without holding native gas tokens\n   - Execute multi-chain transactions without bridging delays\n   - Unified balance view aggregates assets from all supported chains\n   - Automatic route optimization for best execution across chains and protocols",
    "gasless_transactions_citation": "https://docs.enclave.money"
  },
  "polymarket_integration": {
    "order_placement_workflows": "Complete Order Placement Workflow for Polymarket:\n\n**1. Client Initialization:**\nInstall the Polymarket CLOB client:\n```bash\nnpm install @polymarket/clob-client ethers\n```\n\nInitialize the ClobClient with proper configuration:\n```typescript\nimport { ClobClient, Side } from '@polymarket/clob-client';\nimport { ethers } from 'ethers';\n\nconst HOST = \"https://clob.polymarket.com\";\nconst CHAIN_ID = 137; // Polygon mainnet\nconst signatureType = 2; // Gnosis Safe for embedded wallets like Privy\nconst funder = \"POLYMARKET_PROXY_ADDRESS\"; // User's Polymarket Safe address\n\n// Signer comes from Privy embedded wallet\nconst provider = await privyWallet.getEthereumProvider();\nconst ethersProvider = new ethers.BrowserProvider(provider);\nconst signer = await ethersProvider.getSigner();\n```\n\n**2. API Credential Derivation (L1 Authentication):**\nGenerate L2 API credentials using the user's private key:\n```typescript\n// First, create client without credentials\nconst tempClient = new ClobClient(HOST, CHAIN_ID, signer);\n\n// Derive API credentials (requires user signature)\nconst apiCreds = await tempClient.createOrDeriveApiKey();\n// apiCreds contains: { apiKey, apiSecret, apiPassphrase }\n```\n\n**3. Authenticated Client Setup (L2 Authentication):**\n```typescript\nconst client = new ClobClient(\n  HOST,\n  CHAIN_ID,\n  signer,\n  apiCreds,\n  signatureType,\n  funder\n);\n```\n\n**4. Pre-Trading Setup:**\na) Deploy Gnosis Safe Proxy (if not already deployed):\n```typescript\n// Use RelayClient for gasless deployment\nimport { RelayClient } from '@polymarket/builder-relayer-client';\n\nconst relayClient = new RelayClient(HOST, signer);\nconst safeAddress = await relayClient.deploySafe();\n```\n\nb) Set Token Approvals:\n```typescript\n// Approve USDC.e for trading\nawait relayClient.approveUSDC(safeAddress);\n\n// Approve CTF Exchange contract for outcome tokens\nawait relayClient.setApprovalForAll(safeAddress);\n```\n\n**5. Fetch Market Information:**\n```typescript\n// Get token IDs from Gamma API\nconst marketData = await fetch(\n  `https://gamma-api.polymarket.com/markets?slug=market-slug`\n).then(r => r.json());\n\nconst tokenId = marketData.tokens[0].token_id; // For YES outcome\nconst tickSize = marketData.minimum_tick_size; // e.g., \"0.01\"\n```\n\n**6. Create and Place Buy Order:**\n```typescript\nconst buyOrderResponse = await client.createAndPostOrder({\n  tokenID: tokenId,\n  price: 0.65, // Buy YES shares at 65 cents\n  size: 100, // Buy 100 shares\n  side: Side.BUY,\n}, {\n  tickSize: tickSize,\n  negRisk: false\n});\n\nconsole.log('Order placed:', buyOrderResponse.orderID);\n```\n\n**7. Create and Place Sell Order:**\n```typescript\nconst sellOrderResponse = await client.createAndPostOrder({\n  tokenID: tokenId,\n  price: 0.70, // Sell YES shares at 70 cents\n  size: 50, // Sell 50 shares\n  side: Side.SELL,\n}, {\n  tickSize: tickSize,\n  negRisk: false\n});\n\nconsole.log('Sell order placed:', sellOrderResponse.orderID);\n```\n\n**8. Order Types:**\n- **GTC (Good-Til-Cancelled):** Default. Order remains active until filled or cancelled\n- **FOK (Fill-Or-Kill):** Market order that must execute immediately and completely or be cancelled\n- **GTD (Good-Til-Date):** Order expires at a specified timestamp\n\n**9. Market Orders:**\nFor immediate execution at best available price:\n```typescript\n// Market buy (specify dollar amount)\nawait client.createAndPostOrder({\n  tokenID: tokenId,\n  amount: 50, // Spend $50\n  side: Side.BUY,\n}, {\n  orderType: OrderType.FOK\n});\n\n// Market sell (specify share quantity)\nawait client.createAndPostOrder({\n  tokenID: tokenId,\n  size: 100, // Sell 100 shares\n  side: Side.SELL,\n}, {\n  orderType: OrderType.FOK\n});\n```\n\n**10. Order Status Checking:**\n```typescript\nconst order = await client.getOrder(orderID);\nconsole.log('Status:', order.status); // LIVE, MATCHED, etc.\n```\n\n**11. Cancel Order:**\n```typescript\nawait client.cancelOrder(orderID);\n```\n\n**12. Error Handling:**\nCommon errors and solutions:\n- Insufficient balance: Fund the Polymarket proxy wallet with USDC\n- Insufficient allowance: Call setApprovalForAll on CTF contract\n- Invalid token ID: Verify token ID from Gamma API\n- Price outside tick size: Ensure price is multiple of tick size",
    "order_placement_workflows_citation": "https://docs.polymarket.com/developers/CLOB/quickstart",
    "backend_frontend_coordination": "Backend-Frontend Coordination for Transaction Signing in Polymarket Integration:\n\n**Architecture Overview:**\nThe Polymarket integration uses a hybrid signing model where user signatures (via Privy embedded wallets) are combined with builder signatures (server-side) for order attribution and gasless execution.\n\n**1. Frontend Responsibilities:**\n\na) User Authentication and Wallet Management:\n```typescript\n// In your React component\nimport { usePrivy, useWallets } from '@privy-io/react-auth';\n\nfunction TradingComponent() {\n  const { authenticated, login } = usePrivy();\n  const { wallets } = useWallets();\n  \n  if (!authenticated) {\n    return <button onClick={login}>Login with Privy</button>;\n  }\n  \n  const embeddedWallet = wallets[0];\n  // Use this wallet for signing\n}\n```\n\nb) User-Level Signing (EIP-712):\n```typescript\n// Frontend derives API credentials using user's private key\nconst provider = await embeddedWallet.getEthereumProvider();\nconst ethersProvider = new ethers.BrowserProvider(provider);\nconst signer = await ethersProvider.getSigner();\n\n// User signs EIP-712 message to create API credentials\nconst apiCreds = await clobClient.createOrDeriveApiKey();\n// This signature proves wallet ownership and enables L2 auth\n```\n\nc) Session State Management:\n```typescript\n// Store derived credentials for session persistence\nconst [tradingSession, setTradingSession] = useState({\n  apiCreds: null,\n  safeAddress: null,\n  isReady: false\n});\n\n// Persist session to localStorage or state management\nlocalStorage.setItem('polymarket_session', JSON.stringify(tradingSession));\n```\n\n**2. Backend Responsibilities:**\n\na) Builder Credential Management:\n```typescript\n// In your Next.js API route (/api/polymarket/sign/route.ts)\nimport { RemoteSignatureProvider } from '@polymarket/builder-signing-sdk';\n\nconst builderCredentials = {\n  apiKey: process.env.POLYMARKET_BUILDER_API_KEY,\n  apiSecret: process.env.POLYMARKET_BUILDER_SECRET,\n  apiPassphrase: process.env.POLYMARKET_BUILDER_PASSPHRASE\n};\n\n// NEVER expose these to the frontend\n```\n\nb) Remote Signature Endpoint:\n```typescript\n// API route for generating builder HMAC signatures\nexport async function POST(request: Request) {\n  const { method, path, body, timestamp } = await request.json();\n  \n  const signatureProvider = new RemoteSignatureProvider(\n    builderCredentials.apiKey,\n    builderCredentials.apiSecret,\n    builderCredentials.apiPassphrase\n  );\n  \n  const signature = signatureProvider.createHmacSignature({\n    method,\n    path,\n    body,\n    timestamp: timestamp.toString()\n  });\n  \n  return Response.json({ signature });\n}\n```\n\n**3. Coordination Flow for Order Placement:**\n\nStep-by-Step Process:\n\n```typescript\n// FRONTEND: User initiates order\nasync function placeOrder(tokenId: string, price: number, size: number) {\n  // Step 1: User signs order locally with Privy wallet\n  const userSigner = await getPrivySigner();\n  \n  // Step 2: Request builder signature from backend\n  const timestamp = Date.now();\n  const orderPayload = {\n    tokenID: tokenId,\n    price: price,\n    size: size,\n    side: Side.BUY\n  };\n  \n  const builderSignature = await fetch('/api/polymarket/sign', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      method: 'POST',\n      path: '/order',\n      body: JSON.stringify(orderPayload),\n      timestamp\n    })\n  }).then(r => r.json());\n  \n  // Step 3: Combine signatures and submit order\n  const clobClient = new ClobClient(\n    HOST,\n    CHAIN_ID,\n    userSigner,\n    userApiCreds, // User's L2 credentials\n    2, // Signature type (Gnosis Safe)\n    safeAddress // User's Polymarket proxy\n  );\n  \n  // Client internally combines:\n  // - User's EIP-712 signature (proves wallet ownership)\n  // - Builder's HMAC signature (provides attribution)\n  const response = await clobClient.createAndPostOrder(\n    orderPayload,\n    { tickSize: '0.01' }\n  );\n  \n  return response;\n}\n```\n\n**4. Gasless Transaction Coordination:**\n\na) Safe Deployment (One-time):\n```typescript\n// FRONTEND: Request gasless Safe deployment\nimport { RelayClient } from '@polymarket/builder-relayer-client';\n\nconst relayClient = new RelayClient(\n  'https://builder-relayer.polymarket.com',\n  privySigner\n);\n\n// User signs deployment message\nconst safeAddress = await relayClient.deploySafe();\n// Backend relayer pays gas, user only signs\n```\n\nb) Token Approvals (One-time):\n```typescript\n// FRONTEND: Batch approvals in single user signature\nconst approvalsResponse = await relayClient.batchApprovals(\n  safeAddress,\n  [\n    { token: USDC_ADDRESS, spender: CTF_EXCHANGE },\n    { token: CTF_ADDRESS, spender: CTF_EXCHANGE, isNFT: true }\n  ]\n);\n// User signs once, relayer executes both approvals gaslessly\n```\n\n**5. State Synchronization:**\n\n```typescript\n// FRONTEND: Trading session orchestrator\nconst useTradingSession = () => {\n  const [session, setSession] = useState({\n    step: 'initializing', // initializing -> deploying -> approving -> ready\n    safeAddress: null,\n    apiCreds: null\n  });\n  \n  useEffect(() => {\n    async function initSession() {\n      // Step 1: Derive API credentials\n      const creds = await clobClient.createOrDeriveApiKey();\n      setSession(prev => ({ ...prev, apiCreds: creds, step: 'deploying' }));\n      \n      // Step 2: Deploy Safe if needed\n      const safe = await relayClient.deploySafe();\n      setSession(prev => ({ ...prev, safeAddress: safe, step: 'approving' }));\n      \n      // Step 3: Set approvals\n      await relayClient.batchApprovals(safe, [...]);\n      setSession(prev => ({ ...prev, step: 'ready' }));\n    }\n    \n    initSession();\n  }, []);\n  \n  return session;\n};\n```\n\n**6. Security Considerations:**\n\n- User Private Key: Managed client-side by Privy, never sent to backend\n- Builder Credentials: Stored server-side only, never exposed to frontend\n- API Credentials: Derived client-side, can be stored for session persistence\n- Order Signing: Happens client-side with user's key\n- Builder Attribution: HMAC signature added server-side for order attribution\n\n**7. Complete Integration Pattern:**\n\n```typescript\n// providers/TradingProvider.tsx\nexport function TradingProvider({ children }) {\n  const { authenticated } = usePrivy();\n  const { wallets } = useWallets();\n  const session = useTradingSession();\n  \n  const placeOrder = async (params) => {\n    // Get builder signature from backend\n    const builderSig = await getBuilderSignature(params);\n    \n    // Sign and submit with user wallet\n    const result = await clobClient.createAndPostOrder(params);\n    \n    return result;\n  };\n  \n  return (\n    <TradingContext.Provider value={{ session, placeOrder }}>\n      {children}\n    </TradingContext.Provider>\n  );\n}\n```\n\nThis coordination pattern ensures:\n- Non-custodial: Users maintain full control of their private keys\n- Gasless: Builder relayer pays network fees\n- Attribution: Orders are credited to your builder account\n- Security: Credentials never leak between frontend/backend boundaries",
    "backend_frontend_coordination_citation": "https://github.com/Polymarket/privy-safe-builder-example"
  }
}